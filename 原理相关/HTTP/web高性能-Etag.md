# ETag的介绍
上一节我们讲解了Last-Modified，一种协商缓存的策略。对比强缓存，协商缓存通过和服务器协商来决定是否从服务端从新发送资源还是使用缓存在本地的资源通过资源最后修改时间日期的对比。
<br/><br/>
但是，这个其中有一个小问题，比如服务端对某个资源进行了更改，然后又决定不更改了即撤回之前的更改。那么其实资源是没有改变的，更改的只是文件最后更新日期改变了。
<br/><br/>
这是个非常常见的场景。可当客户端请求该资源的时候因为最后更新的时间更改了，即使资源的内容没有任何改动和缓存的版本相同，服务器也会重新再次返回这个资源。这个就会造成资源的浪费。
<br/><br/>
Etag就是解决这个问题的。Etag是服务端生成的一个值，在第一次请求资源会随着资源一起返回给客户端，然后客户端会保存这个值。在客户端下一次请求该资源，就会带上这个值通过设置 If-None-Match，服务端接收值然后对该值验证，如果相同则直接返回 304 Not Modified，即客户端可以使用缓存在客户端的版本。

## 原理
我们现在对Etag的基本使用已经知道了，那么Etag的值一般是如何生成的，以及服务端凭借什么可以验证Etag的值对应的资源是否应该使用客户端缓存的还是服务端应该重新返回给客户端呢？
<br/><br/>
正如我们上面所说的，Last-Modified的不足之处就是如果资源的内容没有改变，只改变了最后更新日期，服务端就会重新返回资源给客户端。

<br/><br/>
那么，我们如果使用资源内容的哈希值作为Etag，当服务端获取客户端传过来的Etag，然后服务端只需要对请求资源做一次hash然后对比客户端传过来的Etag就可以知道该资源是否更改过，这样就能优化之前的不足之处。这就是Etag的用武之地。

## 扩展
那么既然有了Etag，为什么有的网站或者大部分网站还是2者都使用呢？这个的答案就是Etag可能有性能上的不足对比Last-Modified。如果某个资源的hash非常耗费服务端资源，那么还是考虑Last-Modified。所以这个问题最好的解答就是根据需求来选择最适合的那个。